// SPDX-License-Identifier: GPL-3.0-or-later
package pkg

import (
	"io"
	"time"
	"errors"
	"context"

	"net"
	"net/http"

	log "github.com/siamak-amo/v2utils/log"

	core "github.com/xtls/xray-core/core"
	xnet "github.com/xtls/xray-core/common/net"
	conf "github.com/xtls/xray-core/infra/conf"
)

const (
	// Default test endpoint, does not report IP
	Test_Endpoint_goog = "http://www.google.com"

	// API to report IP address
    Test_Endpoint_ip1 = "http://api4.ipify.org"
    Test_Endpoint_ip2 = "http://v4.api.ipinfo.io/ip"
    Test_Endpoint_ip3 = "http://check-host.net/ip"
    Test_Endpoint_ip4 = "http://ipv4.icanhazip.com"
)

var (
	// Timeout to fail a test
	TestTimeout time.Duration = 10 * time.Second
	// Maximum number of endpoints to test
	TestCount int = 3

	// Returned when max allowed tests failed
	Not_Responding_Error = errors.New("Not responding")
)

type TestResult struct {
	IP string
	Duration int64
}

type ConnectivityTester_I interface {
    Test(v2 *V2utils) (error, *TestResult)
}

// Simple connectivity tester
type Simple_Contester struct {
	endpoints []string
}
// Connectivity tester with IP report
type IP_Contester struct {
	endpoints []string
}


// Connectivity testers
var (
	// Simple report of duration and connectivity
	SimpleTester = &Simple_Contester{
		endpoints: []string{
			Test_Endpoint_goog,
			Test_Endpoint_ip1, Test_Endpoint_ip2,
			Test_Endpoint_ip3, Test_Endpoint_ip4,
		},
	};

	// Advanced tester, also reports IP address
	AdvancedTester = &IP_Contester{
		endpoints: []string{
			Test_Endpoint_ip1, Test_Endpoint_ip2,
			Test_Endpoint_ip3, Test_Endpoint_ip4,
		},
	};
)

func (tester *Simple_Contester) Test(v2 *V2utils) (error, *TestResult) {
	for n := 0;; {
		for _, endpoint := range tester.endpoints {
			if n += 1; n > TestCount {
				return Not_Responding_Error, nil;
			}
			if err, dur, _ := v2.test_http(endpoint, false); nil == err {
				return nil, &TestResult{ Duration: dur };
			} else {
				log.Debugf("Test failed - %s\n", err);
			}
		}
	}
	return Not_Responding_Error, nil;
}

func (tester *IP_Contester) Test(v2 *V2utils) (error, *TestResult) {
	for n := 0;; {
		for _, endpoint := range tester.endpoints {
			if n += 1; n > TestCount {
				return Not_Responding_Error, nil;
			}
			if err, dur, body := v2.test_http(endpoint, true); nil == err {
				res := &TestResult{ Duration: dur }
				if ip := net.ParseIP(string(body)); nil != ip {
					res.IP = ip.String()
				} else {
					// The API did not return a valid IP address
					// We cannot do anything about it right now, probably the API
					// itself is broken or changed, so a debug message is enough.
					res.IP = ""
					log.Debugf("Expected IP in the response of %s, but got: %s\n",
						endpoint, string(body));
				}
				return nil, res;
			} else {
				log.Debugf("Test failed - %s\n", err);
			}
		}
	}
	return Not_Responding_Error, nil;
}

func (v2 *V2utils) doTest(tester ConnectivityTester_I) (err error, res *TestResult) {
	if e := v2.Run_Xray(); nil != e {
		return e, nil;
	}
	err, res = tester.Test(v2);
	v2.Kill_Xray();
	return;
}

// This will utilize the xray-core Dial function (DialContext compatible)
func (v2 V2utils) CustomDial(ctx context.Context, network, addr string) (xnet.Conn, error) {
	dst, e := xnet.ParseDestination(network + ":" + addr);
	if nil != e {
		return nil, e
	}
	return core.Dial(ctx, v2.Xray_instance, dst);
}

// @addr:  'http://domain.tld'
func (v2 V2utils) test_http(addr string, include_response bool) (err error, duration int64, body []byte) {
	var req *http.Request; var resp *http.Response;
	ctx, cancel := context.WithTimeout (context.Background(), TestTimeout)
	defer cancel()

	req, err = http.NewRequest (http.MethodGet, addr, nil)
	if nil != err {
		return
	}
	req = req.WithContext(ctx)

	httpTransport := http.Transport{DialContext: v2.CustomDial}
	client := http.Client{Transport: &httpTransport}
	if resp, err = client.Do(req); nil != err {
		return
	}
	defer resp.Body.Close();

	deadline, _ := ctx.Deadline()
	duration = (TestTimeout - time.Until(deadline)).Milliseconds();

	if include_response {
		// To read an IP address form response, 256 is more than enough
		body, err = io.ReadAll(io.LimitReader(resp.Body, 256))
	}
	return
}

// Tests a minimal config generated by DEF_Test_Template
// It will not create any local listening proxy, instead
// it passes a simple HTTP request through the running
// xray-core instance @v2.Xray_instance.
func (v2 *V2utils) Test_URL(url string, tester ConnectivityTester_I) (error, *TestResult) {
	v2.Apply_template_bystr(DEF_Test_Template);
	if e := v2.Init_Outbound_byURL(url); nil != e {
		return e, nil
	}
	return v2.doTest(tester);
}

// Tests a config file @path
func (v2 *V2utils) Test_CFG(path string, tester ConnectivityTester_I) (error, *TestResult) {
	if e := v2.Apply_template(path); nil != e || nil == v2.CFG {
		return e, nil
	}

	// We should eliminate 'inbounds' section for testing,
	// as the inbound proxy port(s), may be in use, so may
	// lead to true-negative results.
	v2.CFG.InboundConfigs = nil

	// Logs from the instance, interferes with our logs
	if nil != v2.CFG.LogConfig {
		v2.CFG.LogConfig.LogLevel = "none"
	} else {
		v2.CFG.LogConfig = &conf.LogConfig{LogLevel: "none"}
	}

	return v2.doTest(tester);
}
