// SPDX-License-Identifier: GPL-3.0-or-later
package pkg

import (
	"time"
	"errors"
	"context"
	"net/http"

	core "github.com/xtls/xray-core/core"
	xnet "github.com/xtls/xray-core/common/net"
	conf "github.com/xtls/xray-core/infra/conf"
)

const (
	// Default test endpoint, does not report IP
	Test_Endpoint_goog = "http://www.google.com"

	// API to report IP address
    Test_Endpoint_ip1 = "http://api4.ipify.org"
    Test_Endpoint_ip2 = "http://v4.api.ipinfo.io/ip"
    Test_Endpoint_ip3 = "http://check-host.net/ip"
    Test_Endpoint_ip4 = "http://ipv4.icanhazip.com"
)

var (
	// Timeout to fail a test
	TestTimeout time.Duration = 10 * time.Second
	// Maximum number of endpoints to test
	TestCount int = 3

	GiveUp_Testing = errors.New("i gave up.")
)

type TestResult struct {
	IP string
	Duration int64
}

type ConnectivityTester_I interface {
    Test(v2 *V2utils) (error, *TestResult)
}

// Simple connectivity tester
type Simple_Contester struct {
	endpoints []string
}
// Connectivity tester with IP report
type IP_Contester struct {
	endpoints []string
}


// Connectivity testers
var (
	// Simple report of duration and connectivity
	SimpleTester = &Simple_Contester{
		endpoints: []string{
			Test_Endpoint_goog,
			Test_Endpoint_ip1, Test_Endpoint_ip2,
			Test_Endpoint_ip3, Test_Endpoint_ip4,
		},
	};

	// Advanced tester, also reports IP address
	AdvancedTester = &IP_Contester{
		endpoints: []string{
			Test_Endpoint_ip1, Test_Endpoint_ip2,
			Test_Endpoint_ip3, Test_Endpoint_ip4,
		},
	};
)

func (tester *Simple_Contester) Test(v2 *V2utils) (error, *TestResult) {
	for n := 0;; {
		for _, endpoint := range tester.endpoints {
			if n += 1; n > TestCount {
				return GiveUp_Testing, nil;
			}
			if err, time := v2.test_http(endpoint); nil == err {
				return nil, &TestResult{Duration: time};
			} else {
				// log it maybe:
				// println(err.Error());
			}
		}
	}
	return GiveUp_Testing, nil;
}

func (tester *IP_Contester) Test(v2 *V2utils) (error, *TestResult) {
	panic (errors.New("Not implemented."));
	return nil, nil;
}

func (v2 *V2utils) doTest(tester ConnectivityTester_I) (err error, res *TestResult) {
	if e := v2.Run_Xray(); nil != e {
		return e, nil;
	}
	err, res = tester.Test(v2);
	v2.Kill_Xray();
	return;
}

// This will utilize the xray-core Dial function (DialContext compatible)
func (v2 V2utils) CustomDial(ctx context.Context, network, addr string) (xnet.Conn, error) {
	dst, e := xnet.ParseDestination(network + ":" + addr);
	if nil != e {
		return nil, e
	}
	return core.Dial(ctx, v2.Xray_instance, dst);
}

// @addr:  'http://domain.tld'
func (v2 V2utils) test_http(addr string) (res error, duration int64) {
	ctx, cancel := context.WithTimeout (context.Background(), TestTimeout)
	defer cancel()
	req, err := http.NewRequest (http.MethodGet, addr, nil)
	if nil != err {
		return err, 0
	}
	req = req.WithContext(ctx)

	httpTransport := http.Transport{DialContext: v2.CustomDial}
	client := http.Client{Transport: &httpTransport}
	if _, err := client.Do(req); err != nil {
		return err, 0
	}

	deadline, _ := ctx.Deadline()
	return nil, (TestTimeout - time.Until(deadline)).Milliseconds();
}

// Tests a minimal config generated by DEF_Test_Template
// It will not create any local listening proxy, instead
// it passes a simple HTTP request through the running
// xray-core instance @v2.Xray_instance.
func (v2 *V2utils) Test_URL(url string, tester ConnectivityTester_I) (error, *TestResult) {
	v2.Apply_template_bystr(DEF_Test_Template);
	if e := v2.Init_Outbound_byURL(url); nil != e {
		return e, nil
	}
	return v2.doTest(tester);
}

// Tests a config file @path
func (v2 *V2utils) Test_CFG(path string, tester ConnectivityTester_I) (error, *TestResult) {
	if e := v2.Apply_template(path); nil != e || nil == v2.CFG {
		return e, nil
	}

	// We should eliminate 'inbounds' section for testing,
	// as the inbound proxy port(s), may be in use, so may
	// lead to true-negative results.
	v2.CFG.InboundConfigs = nil

	// Logs from the instance, interferes with our logs
	if nil != v2.CFG.LogConfig {
		v2.CFG.LogConfig.LogLevel = "none"
	} else {
		v2.CFG.LogConfig = &conf.LogConfig{LogLevel: "none"}
	}

	return v2.doTest(tester);
}
